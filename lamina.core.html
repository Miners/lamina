<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>lamina.core documentation</title></head><body><div id="header"><h1><a href="index.html">Lamina 0.5.0-beta11 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="lamina.api.html"><span>lamina.api</span></a></li><li class="current"><a href="lamina.core.html"><span>lamina.core</span></a></li><li><a href="lamina.executor.html"><span>lamina.executor</span></a></li><li><a href="lamina.stats.html"><span>lamina.stats</span></a></li><li><a href="lamina.time.html"><span>lamina.time</span></a></li><li><a href="lamina.trace.html"><span>lamina.trace</span></a></li><li><a href="lamina.viz.html"><span>lamina.viz</span></a></li><li><a href="lamina.walk.html"><span>lamina.walk</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="lamina.core.html#var-aggregate"><span>aggregate</span></a></li><li><a href="lamina.core.html#var-async-result%3F"><span>async-result?</span></a></li><li><a href="lamina.core.html#var-atom-sink"><span>atom-sink</span></a></li><li><a href="lamina.core.html#var-cancel-callback"><span>cancel-callback</span></a></li><li><a href="lamina.core.html#var-channel"><span>channel</span></a></li><li><a href="lamina.core.html#var-channel*"><span>channel*</span></a></li><li><a href="lamina.core.html#var-channel-%3Elazy-seq"><span>channel-&gt;lazy-seq</span></a></li><li><a href="lamina.core.html#var-channel-%3Eseq"><span>channel-&gt;seq</span></a></li><li><a href="lamina.core.html#var-channel-pair"><span>channel-pair</span></a></li><li><a href="lamina.core.html#var-channel%3F"><span>channel?</span></a></li><li><a href="lamina.core.html#var-close"><span>close</span></a></li><li><a href="lamina.core.html#var-close-on-idle"><span>close-on-idle</span></a></li><li><a href="lamina.core.html#var-closed-channel"><span>closed-channel</span></a></li><li><a href="lamina.core.html#var-closed-result"><span>closed-result</span></a></li><li><a href="lamina.core.html#var-closed%3F"><span>closed?</span></a></li><li><a href="lamina.core.html#var-combine-latest"><span>combine-latest</span></a></li><li><a href="lamina.core.html#var-complete"><span>complete</span></a></li><li><a href="lamina.core.html#var-concat*"><span>concat*</span></a></li><li><a href="lamina.core.html#var-defer-onto-queue"><span>defer-onto-queue</span></a></li><li><a href="lamina.core.html#var-distribute-aggregate"><span>distribute-aggregate</span></a></li><li><a href="lamina.core.html#var-distributor"><span>distributor</span></a></li><li><a href="lamina.core.html#var-drained-result"><span>drained-result</span></a></li><li><a href="lamina.core.html#var-drained%3F"><span>drained?</span></a></li><li><a href="lamina.core.html#var-drop*"><span>drop*</span></a></li><li><a href="lamina.core.html#var-enqueue"><span>enqueue</span></a></li><li><a href="lamina.core.html#var-enqueue-and-close"><span>enqueue-and-close</span></a></li><li><a href="lamina.core.html#var-error"><span>error</span></a></li><li><a href="lamina.core.html#var-error-result"><span>error-result</span></a></li><li><a href="lamina.core.html#var-error-value"><span>error-value</span></a></li><li><a href="lamina.core.html#var-expiring-result"><span>expiring-result</span></a></li><li><a href="lamina.core.html#var-filter*"><span>filter*</span></a></li><li><a href="lamina.core.html#var-force-close"><span>force-close</span></a></li><li><a href="lamina.core.html#var-force-error"><span>force-error</span></a></li><li><a href="lamina.core.html#var-fork"><span>fork</span></a></li><li><a href="lamina.core.html#var-ground"><span>ground</span></a></li><li><a href="lamina.core.html#var-grounded-channel"><span>grounded-channel</span></a></li><li><a href="lamina.core.html#var-idle-result"><span>idle-result</span></a></li><li><a href="lamina.core.html#var-join"><span>join</span></a></li><li><a href="lamina.core.html#var-join-%3E%3E"><span>join-&gt;&gt;</span></a></li><li><a href="lamina.core.html#var-last*"><span>last*</span></a></li><li><a href="lamina.core.html#var-lazy-seq-%3Echannel"><span>lazy-seq-&gt;channel</span></a></li><li><a href="lamina.core.html#var-map*"><span>map*</span></a></li><li><a href="lamina.core.html#var-mapcat*"><span>mapcat*</span></a></li><li><a href="lamina.core.html#var-merge-channels"><span>merge-channels</span></a></li><li><a href="lamina.core.html#var-merge-results"><span>merge-results</span></a></li><li><a href="lamina.core.html#var-named-channel"><span>named-channel</span></a></li><li><a href="lamina.core.html#var-on-closed"><span>on-closed</span></a></li><li><a href="lamina.core.html#var-on-drained"><span>on-drained</span></a></li><li><a href="lamina.core.html#var-on-error"><span>on-error</span></a></li><li><a href="lamina.core.html#var-on-realized"><span>on-realized</span></a></li><li><a href="lamina.core.html#var-partition*"><span>partition*</span></a></li><li><a href="lamina.core.html#var-partition-all*"><span>partition-all*</span></a></li><li><a href="lamina.core.html#var-partition-every"><span>partition-every</span></a></li><li><a href="lamina.core.html#var-periodically"><span>periodically</span></a></li><li><a href="lamina.core.html#var-permanent-channel"><span>permanent-channel</span></a></li><li><a href="lamina.core.html#var-pipeline"><span>pipeline</span></a></li><li><a href="lamina.core.html#var-read-channel"><span>read-channel</span></a></li><li><a href="lamina.core.html#var-read-channel*"><span>read-channel*</span></a></li><li><a href="lamina.core.html#var-read-merge"><span>read-merge</span></a></li><li><a href="lamina.core.html#var-receive"><span>receive</span></a></li><li><a href="lamina.core.html#var-receive-all"><span>receive-all</span></a></li><li><a href="lamina.core.html#var-receive-in-order"><span>receive-in-order</span></a></li><li><a href="lamina.core.html#var-redirect"><span>redirect</span></a></li><li><a href="lamina.core.html#var-reduce*"><span>reduce*</span></a></li><li><a href="lamina.core.html#var-reductions*"><span>reductions*</span></a></li><li><a href="lamina.core.html#var-remove*"><span>remove*</span></a></li><li><a href="lamina.core.html#var-result-channel"><span>result-channel</span></a></li><li><a href="lamina.core.html#var-run-pipeline"><span>run-pipeline</span></a></li><li><a href="lamina.core.html#var-sample-every"><span>sample-every</span></a></li><li><a href="lamina.core.html#var-sink"><span>sink</span></a></li><li><a href="lamina.core.html#var-sink-%3E%3E"><span>sink-&gt;&gt;</span></a></li><li><a href="lamina.core.html#var-siphon"><span>siphon</span></a></li><li><a href="lamina.core.html#var-siphon-%3E%3E"><span>siphon-&gt;&gt;</span></a></li><li><a href="lamina.core.html#var-splice"><span>splice</span></a></li><li><a href="lamina.core.html#var-split"><span>split</span></a></li><li><a href="lamina.core.html#var-success-result"><span>success-result</span></a></li><li><a href="lamina.core.html#var-take*"><span>take*</span></a></li><li><a href="lamina.core.html#var-take-while*"><span>take-while*</span></a></li><li><a href="lamina.core.html#var-tap"><span>tap</span></a></li><li><a href="lamina.core.html#var-timed-result"><span>timed-result</span></a></li><li><a href="lamina.core.html#var-transactional%3F"><span>transactional?</span></a></li><li><a href="lamina.core.html#var-transitions"><span>transitions</span></a></li><li><a href="lamina.core.html#var-wait-for-message"><span>wait-for-message</span></a></li><li><a href="lamina.core.html#var-wait-for-result"><span>wait-for-result</span></a></li><li><a href="lamina.core.html#var-wait-stage"><span>wait-stage</span></a></li><li><a href="lamina.core.html#var-watch-channel"><span>watch-channel</span></a></li><li><a href="lamina.core.html#var-with-timeout"><span>with-timeout</span></a></li><li><a href="lamina.core.html#var-zip"><span>zip</span></a></li><li><a href="lamina.core.html#var-zip-all"><span>zip-all</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>lamina.core documentation</h2><pre class="doc"></pre><div class="public" id="var-aggregate"><h3>aggregate</h3><div class="usage"><code>(aggregate {:keys [facet flush? task-queue period], :or {task-queue t/default-task-queue}} ch)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-async-result%3F"><h3>async-result?</h3><div class="usage"><code>(async-result? x)</code></div><pre class="doc">Returns true if 'x' is a result.
</pre></div><div class="public" id="var-atom-sink"><h3>atom-sink</h3><div class="usage"><code>(atom-sink ch)</code><code>(atom-sink initial-value ch)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-cancel-callback"><h3>cancel-callback</h3><div class="usage"><code>(cancel-callback channel callback)</code></div><pre class="doc">Cancels a callback registered with receive, receive-all, on-closed, on-drained, or on-error.
</pre></div><div class="public" id="var-channel"><h3>channel</h3><div class="usage"><code>(channel &amp; messages)</code></div><pre class="doc">Returns a channel containing the given messages.
</pre></div><div class="public" id="var-channel*"><h3>channel*</h3><div class="usage"><code>(channel* &amp; {:keys [grounded? permanent? transactional? messages description meta], :as options})</code></div><pre class="doc">A general-purpose channel creator.  Can be used to mix and match various properties, such as

(channel* :grounded? true, :description &quot;my very own grounded channel&quot;)

:grounded?        - ensures that messages cannot accumulate in the queue
:permanent?       - ensures that the channel cannot be closed or be put in an error state
:transactional?   - determines whether the channel's queue is transactional
:messages         - sequence of zero or more messages that will be in the channel's queue
:description      - a string that will be diplayed in channel visualizations
:meta             - initial metadata</pre></div><div class="public" id="var-channel-%3Elazy-seq"><h3>channel-&gt;lazy-seq</h3><div class="usage"><code>(channel-&gt;lazy-seq ch)</code><code>(channel-&gt;lazy-seq ch timeout)</code></div><pre class="doc">Returns a sequence.  As elements of the sequence are realized, messages from the
source channel are consumed.  If there are no messages are available to be
consumed, execution will block until one is available.

A 'timeout' can be defined, either as a number or a no-arg function that returns a
number.  Each time the seq must wait for a message to consume, it will only wait
that many milliseconds before giving up and ending the sequence.</pre></div><div class="public" id="var-channel-%3Eseq"><h3>channel-&gt;seq</h3><div class="usage"><code>(channel-&gt;seq ch)</code><code>(channel-&gt;seq ch timeout)</code></div><pre class="doc">An eager variant of channel-&gt;lazy-seq.  Blocks until the channel has been drained,
or until 'timeout' milliseconds have elapsed.</pre></div><div class="public" id="var-channel-pair"><h3>channel-pair</h3><div class="usage"><code>(channel-pair)</code></div><pre class="doc">Returns a pair of channels, where all messages enqueued into one channel can
be received by the other, and vice-versa.  Closing one channel will automatically
close the other.</pre></div><div class="public" id="var-channel%3F"><h3>channel?</h3><div class="usage"><code>(channel? x)</code></div><pre class="doc">Returns true if 'x' is a channel.  This does not encompass result-channels.
</pre></div><div class="public" id="var-close"><h3>close</h3><div class="usage"><code>(close channel)</code></div><pre class="doc">Closes the channel. Returns if successful, false if the channel is permanent, already closed,
or in an error state.</pre></div><div class="public" id="var-close-on-idle"><h3>close-on-idle</h3><div class="usage"><code>(close-on-idle interval ch)</code><code>(close-on-idle interval task-queue ch)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-closed-channel"><h3>closed-channel</h3><div class="usage"><code>(closed-channel &amp; messages)</code></div><pre class="doc">Returns a closed channel containing the given messages.
</pre></div><div class="public" id="var-closed-result"><h3>closed-result</h3><div class="usage"><code>(closed-result channel)</code></div><pre class="doc">Returns a result-channel that will emit a result when the channel is closed, or emit an error
if the channel goes into an error state.</pre></div><div class="public" id="var-closed%3F"><h3>closed?</h3><div class="usage"><code>(closed? channel)</code></div><pre class="doc">Returns true if the channel is closed, false otherwise. 
</pre></div><div class="public" id="var-combine-latest"><h3>combine-latest</h3><div class="usage"><code>(combine-latest f &amp; channels)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-complete"><h3>complete</h3><div class="usage"><code>(complete value)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-concat*"><h3>concat*</h3><div class="usage"><code>(concat* ch)</code></div><pre class="doc">A dual to concat.

(concat* (channel [1 2] [2 3])) =&gt; [1 2 3 4]</pre></div><div class="public" id="var-defer-onto-queue"><h3>defer-onto-queue</h3><div class="usage"><code>(defer-onto-queue task-queue time-facet ch)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-distribute-aggregate"><h3>distribute-aggregate</h3><div class="usage"><code>(distribute-aggregate {:keys [facet generator period task-queue], :or {task-queue t/default-task-queue}} ch)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-distributor"><h3>distributor</h3><div class="usage"><code>(distributor {:keys [facet generator]})</code></div><pre class="doc">Returns a channel.

Messages enqueued into this channel are split into multiple streams, grouped by
(facet msg). When a new facet-value is encountered, (generator facet ch)
is called, allowing messages with that facet-value to be handled appropriately.

If a facet channel is closed, it will be removed from the distributor, and
a new channel will be generated when another message of that type is enqueued.
This allows the use of (close-on-idle ch ...), if facet-values will change over
time.

Given messages with the form {:type :foo, :value 1}, to print the mean values of all
types:

(distributor
  {:facet     :type
   :generator (fn [facet-value ch]
                (siphon
                  (-&gt;&gt; ch (map* :value) moving-average)
                  (sink #(println &quot;average for&quot; facet-value &quot;is&quot; %))))})</pre></div><div class="public" id="var-drained-result"><h3>drained-result</h3><div class="usage"><code>(drained-result channel)</code></div><pre class="doc">Returns a result-channel that will emit a result when the channel is drained, or emit an error
if the channel goes into an error state.</pre></div><div class="public" id="var-drained%3F"><h3>drained?</h3><div class="usage"><code>(drained? channel)</code></div><pre class="doc">Returns true if the channel is drained, false otherwise.
</pre></div><div class="public" id="var-drop*"><h3>drop*</h3><div class="usage"><code>(drop* n ch)</code></div><pre class="doc">A dual to drop.

(drop* 2 (closed-channel 1 2 3 4) =&gt; [3 4]</pre></div><div class="public" id="var-enqueue"><h3>enqueue</h3><div class="usage"><code>(enqueue channel message)</code><code>(enqueue channel message &amp; messages)</code></div><pre class="doc">Enqueues the message or messages into the channel.
</pre></div><div class="public" id="var-enqueue-and-close"><h3>enqueue-and-close</h3><div class="usage"><code>(enqueue-and-close ch &amp; messages)</code></div><pre class="doc">Enqueues the message or messages into the channel, and then closes the channel.
</pre></div><div class="public" id="var-error"><h3>error</h3><div class="usage"><code>(error channel err)</code></div><pre class="doc">Puts the channel or result-channel into an error state.
</pre></div><div class="public" id="var-error-result"><h3>error-result</h3><div class="usage"><code>(error-result error)</code><code>(error-result error listener)</code></div><pre class="doc">Returns a result already realized with an error.
</pre></div><div class="public" id="var-error-value"><h3>error-value</h3><div class="usage"><code>(error-value x default-value)</code></div><pre class="doc">Returns the error-value of the channel or async-result if it's in an error state, and 'default-value'
otherwise</pre></div><div class="public" id="var-expiring-result"><h3>expiring-result</h3><div class="usage"><code>(expiring-result interval)</code><code>(expiring-result interval task-queue)</code></div><pre class="doc">Returns a result-channel that will be realized as a 'lamina/timeout!' error if a value is not enqueued within
'interval' milliseconds.</pre></div><div class="public" id="var-filter*"><h3>filter*</h3><div class="usage"><code>(filter* f channel)</code></div><pre class="doc">A dual to filter.

(filter* odd? (channel 1 2 3)) =&gt; [1 3]</pre></div><div class="public" id="var-force-close"><h3>force-close</h3><div class="usage"><code>(force-close channel)</code></div><pre class="doc">Closes the channel, even if it is permanent. Returns if successful, false if the channel is
already closed or in an error state.</pre></div><div class="public" id="var-force-error"><h3>force-error</h3><div class="usage"><code>(force-error channel err)</code></div><pre class="doc">Puts the channel or result-channel into an error state, even if it's permanent.
</pre></div><div class="public" id="var-fork"><h3>fork</h3><div class="usage"><code>(fork channel)</code></div><pre class="doc">Returns a channel which is an exact duplicate of the source channel, containing all messages
in the source channel's queue, and emitting all messages emitted by the source channel.

If the forked channel is closed, the source channel is unaffected.  However, if the source
channel is closed all forked channels are closed.  Similar propagation rules apply to error
states.</pre></div><div class="public" id="var-ground"><h3>ground</h3><div class="usage"><code>(ground ch)</code></div><pre class="doc">Ensures that messages will not accumulate in the channel's queue.
</pre></div><div class="public" id="var-grounded-channel"><h3>grounded-channel</h3><div class="usage"><code>(grounded-channel)</code></div><pre class="doc">Returns a channel that cannot accumulate messages.
</pre></div><div class="public" id="var-idle-result"><h3>idle-result</h3><div class="usage"><code>(idle-result interval ch)</code><code>(idle-result interval task-queue ch)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-join"><h3>join</h3><div class="usage"><code>(join src dst)</code><code>(join src dst &amp; rest)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-join-%3E%3E"><h3>join-&gt;&gt;</h3><div class="usage"><code>(join-&gt;&gt; &amp; transforms+downstream-channel)</code></div><pre class="doc">A variant of sink-&gt;&gt; where the last argument is assumed to be a channel,
and the transform chain is joined to it.

(join-&gt;&gt; (map* inc) (map* dec) (named-channel :foo))

expands to

(let [ch (channel)]
  (join
    (-&gt;&gt; ch (map* inc) (map* dec))
    (named-channel :foo))
  ch)</pre></div><div class="public" id="var-last*"><h3>last*</h3><div class="usage"><code>(last* ch)</code></div><pre class="doc">A dual to last.
</pre></div><div class="public" id="var-lazy-seq-%3Echannel"><h3>lazy-seq-&gt;channel</h3><div class="usage"><code>(lazy-seq-&gt;channel s)</code></div><pre class="doc">Returns a channel representing the elements of the sequence.
</pre></div><div class="public" id="var-map*"><h3>map*</h3><div class="usage"><code>(map* f channel)</code></div><pre class="doc">A dual to map.

(map* inc (channel 1 2 3)) =&gt; [2 3 4]</pre></div><div class="public" id="var-mapcat*"><h3>mapcat*</h3><div class="usage"><code>(mapcat* f ch)</code></div><pre class="doc">A dual to mapcat.

(mapcat* reverse (channel [1 2] [3 4])) =&gt; [2 1 4 3]</pre></div><div class="public" id="var-merge-channels"><h3>merge-channels</h3><div class="usage"><code>(merge-channels &amp; channels)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-merge-results"><h3>merge-results</h3><div class="usage"><code>(merge-results &amp; results)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-named-channel"><h3>named-channel</h3><div class="usage"><code>(named-channel id on-create)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-on-closed"><h3>on-closed</h3><div class="usage"><code>(on-closed channel callback)</code></div><pre class="doc">Registers a callback that will be invoked with no arguments when the channel is closed, or
immediately if it has already been closed.  This callback will only be invoked once, and can
be cancelled using cancel-callback.</pre></div><div class="public" id="var-on-drained"><h3>on-drained</h3><div class="usage"><code>(on-drained channel callback)</code></div><pre class="doc">Registers a callback that will be invoked with no arguments when the channel is drained, or
immediately if it has already been drained.  This callback will only be invoked once, and can
be cancelled using cancel-callback.</pre></div><div class="public" id="var-on-error"><h3>on-error</h3><div class="usage"><code>(on-error channel callback)</code></div><pre class="doc">Registers a callback that will be called with the error when the channel enters an error state,
or immediately if it's already in an error state.  This callback will only be invoked once,
and can be cancelled using cancel-callback.</pre></div><div class="public" id="var-on-realized"><h3>on-realized</h3><div class="usage"><code>(on-realized result-channel on-success on-error)</code></div><pre class="doc">Allows two callbacks to be registered on a result-channel, one in the case of a
value, the other in case of an error.

This often can and should be replaced by a pipeline.</pre></div><div class="public" id="var-partition*"><h3>partition*</h3><div class="usage"><code>(partition* n ch)</code><code>(partition* n step ch)</code></div><pre class="doc">A dual to partition.

(partition* 2 (channel 1 2 3)) =&gt; [[1 2]]</pre></div><div class="public" id="var-partition-all*"><h3>partition-all*</h3><div class="usage"><code>(partition-all* n ch)</code><code>(partition-all* n step ch)</code></div><pre class="doc">A dual to partition-all.

(partition-all* 2 (closed-channel 1 2 3)) =&gt; [[1 2] [3]]</pre></div><div class="public" id="var-partition-every"><h3>partition-every</h3><div class="usage"><code>(partition-every {:keys [period task-queue], :or {task-queue t/default-task-queue}} ch)</code></div><pre class="doc">Takes a source channel, and returns a channel that repeatedly emits a collection
of all messages from the source channel in the last 'period' milliseconds.</pre></div><div class="public" id="var-periodically"><h3>periodically</h3><div class="usage"><code>(periodically period f)</code><code>(periodically period f task-queue)</code></div><pre class="doc">Returns a channel.  Every 'period' milliseconds, 'f' is invoked with no arguments
and the value is emitted as a message.</pre></div><div class="public" id="var-permanent-channel"><h3>permanent-channel</h3><div class="usage"><code>(permanent-channel &amp; messages)</code></div><pre class="doc">Returns a channel which cannot be closed or put into an error state.
</pre></div><div class="public" id="var-pipeline"><h3>pipeline</h3><div class="usage"><code>(pipeline &amp; opts+stages)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-read-channel"><h3>read-channel</h3><div class="usage"><code>(read-channel channel)</code></div><pre class="doc">Returns a result-channel representing the next message from the channel.  Only one
result-channel can represent any given message; calling (read-channel ...) multiple times
will always consume multiple messages.

Enqueueing a value into the result-channel before it is realized will prevent the message
from being consumed, effectively cancelling the read-channel call.</pre></div><div class="public" id="var-read-channel*"><h3>read-channel*</h3><div class="usage"><code>(read-channel* ch &amp; {:keys [timeout predicate result on-timeout on-error on-false], :as options})</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-read-merge"><h3>read-merge</h3><div class="usage"><code>(read-merge read-fn merge-fn)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-receive"><h3>receive</h3><div class="usage"><code>(receive channel callback)</code></div><pre class="doc">Registers a callback that will be invoked with the next message enqueued into the channel, or
the first message already in the queue.  Only one callback can consume any given message;
registering multiple callbacks will consume multiple messages.

This can be cancelled using cancel-callback.</pre></div><div class="public" id="var-receive-all"><h3>receive-all</h3><div class="usage"><code>(receive-all channel callback)</code></div><pre class="doc">Registers a callback that will consume all messages currently in the queue, and all
subsequent messages that are enqueued into the channel.

This can be cancelled using cancel-callback.</pre></div><div class="public" id="var-receive-in-order"><h3>receive-in-order</h3><div class="usage"><code>(receive-in-order ch f)</code></div><pre class="doc">Consumes messages from the source channel, passing them to 'f' one at a time.  If
'f' returns a result-channel, consumption of the next message is deferred until
it's realized.

If an exception is thrown or the return result is realized as an error, the source
channel is put into an error state.</pre></div><div class="public" id="var-redirect"><h3>redirect</h3><div class="usage"><code>(redirect pipeline value)</code></div><pre class="doc">If returned from a pipeline stage, redirects the pipeline flow to the beginning
of 'pipeline', with an initial value of 'value'.</pre></div><div class="public" id="var-reduce*"><h3>reduce*</h3><div class="usage"><code>(reduce* f ch)</code><code>(reduce* f val ch)</code></div><pre class="doc">A dual to reduce.  Returns a result-channel that emits the final reduced value
when the source channel has been drained.

(reduce* max (channel 1 3 2)) =&gt; 3</pre></div><div class="public" id="var-reductions*"><h3>reductions*</h3><div class="usage"><code>(reductions* f ch)</code><code>(reductions* f val ch)</code></div><pre class="doc">A dual to reductions.

(reductions* max (channel 1 3 2)) =&gt; [1 3 3]</pre></div><div class="public" id="var-remove*"><h3>remove*</h3><div class="usage"><code>(remove* f channel)</code></div><pre class="doc">A dual to remove.

(remove* even? (channel 2 3 4)) =&gt; [3]</pre></div><div class="public" id="var-result-channel"><h3>result-channel</h3><div class="usage"><code>(result-channel)</code><code>(result-channel listener)</code></div><pre class="doc">Returns a result-channel, representing an unrealized value or error.
</pre></div><div class="public" id="var-run-pipeline"><h3>run-pipeline</h3><div class="usage"><code>(run-pipeline value &amp; opts+stages)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-sample-every"><h3>sample-every</h3><div class="usage"><code>(sample-every {:keys [period task-queue], :or {task-queue t/default-task-queue}} ch)</code></div><pre class="doc">Takes a source channel, and returns a channel that emits the most recent message
from the source channel every 'period' milliseconds.</pre></div><div class="public" id="var-sink"><h3>sink</h3><div class="usage"><code>(sink callback)</code></div><pre class="doc">Creates a channel which will forward all messages to 'callback'.
</pre></div><div class="public" id="var-sink-%3E%3E"><h3>sink-&gt;&gt;</h3><div class="usage"><code>(sink-&gt;&gt; &amp; transforms+callback)</code></div><pre class="doc">Creates a channel, pipes it through the -&gt;&gt; operator, and sends the
resulting stream into the callback. This can be useful when defining
:probes for an instrumented function, among other places.

(sink-&gt;&gt; (map* inc) (map* dec) println)

expands to

(let [ch (channel)]
  (receive-all
    (-&gt;&gt; ch (map* inc) (map* dec))
    println)
  ch)</pre></div><div class="public" id="var-siphon"><h3>siphon</h3><div class="usage"><code>(siphon src dst)</code><code>(siphon src dst &amp; rest)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-siphon-%3E%3E"><h3>siphon-&gt;&gt;</h3><div class="usage"><code>(siphon-&gt;&gt; &amp; transforms+downstream-channel)</code></div><pre class="doc">A variant of sink-&gt;&gt; where the last argument is assumed to be a channel,
and the contents of the transform chain are siphoned into it.

(siphon-&gt;&gt; (map* inc) (map* dec) (named-channel :foo))

expands to

(let [ch (channel)]
  (siphon
    (-&gt;&gt; ch (map* inc) (map* dec))
    (named-channel :foo))
  ch)</pre></div><div class="public" id="var-splice"><h3>splice</h3><div class="usage"><code>(splice emitter receiver)</code></div><pre class="doc">Returns a channel where all messages are enqueud into 'receiver', and
consumed from 'emitter'.</pre></div><div class="public" id="var-split"><h3>split</h3><div class="usage"><code>(split &amp; downstream-channels)</code></div><pre class="doc">Returns a channel which will forward each message to all downstream-channels.
This can be used with sink-&gt;&gt;, siphon-&gt;&gt;, and join-&gt;&gt; to define complex
message flows:

(join-&gt;&gt; (map* inc)
  (split
    (sink-&gt;&gt; (filter* even?) log-even)
    (sink-&gt;&gt; (filter* odd?) log-odd)))</pre></div><div class="public" id="var-success-result"><h3>success-result</h3><div class="usage"><code>(success-result value)</code><code>(success-result value listener)</code></div><pre class="doc">Returns a result already realized with a value.
</pre></div><div class="public" id="var-take*"><h3>take*</h3><div class="usage"><code>(take* n ch)</code></div><pre class="doc">A dual to take.

(take* 2 (channel 1 2 3)) =&gt; [1 2]</pre></div><div class="public" id="var-take-while*"><h3>take-while*</h3><div class="usage"><code>(take-while* f ch)</code></div><pre class="doc">A dual to take-while.

(take-while* pos? (channel 1 2 0 4)) =&gt; [1 2]</pre></div><div class="public" id="var-tap"><h3>tap</h3><div class="usage"><code>(tap channel)</code></div><pre class="doc">Behaves like 'fork', except that the source channel will not remain open if only the tap
exists downstream.

If the tap channel is closed, the source channel is unaffected.  However, if the source
channel is closed all tap channels are closed.  Similar propagation rules apply to error
states.</pre></div><div class="public" id="var-timed-result"><h3>timed-result</h3><div class="usage"><code>(timed-result interval)</code><code>(timed-result interval value)</code><code>(timed-result interval value task-queue)</code></div><pre class="doc">Returns a result-channel that will be realized as 'value' (defaulting to nil) in 'interval' milliseconds.
</pre></div><div class="public" id="var-transactional%3F"><h3>transactional?</h3><div class="usage"><code>(transactional? channel)</code></div><pre class="doc">Returns true if the channel's queue is transactional, false otherwise.
</pre></div><div class="public" id="var-transitions"><h3>transitions</h3><div class="usage"><code>(transitions ch)</code></div><pre class="doc">Emits messages only when they differ from the preceding message.
</pre></div><div class="public" id="var-wait-for-message"><h3>wait-for-message</h3><div class="usage"><code>(wait-for-message ch)</code><code>(wait-for-message ch timeout)</code></div><pre class="doc">Blocks for the next message from the channel. If the timeout elapses without a message,
throws a java.util.concurrent.TimeoutException.</pre></div><div class="public" id="var-wait-for-result"><h3>wait-for-result</h3><div class="usage"><code>(wait-for-result result-channel)</code><code>(wait-for-result result-channel timeout)</code></div><pre class="doc">Waits for the result to be realized. If the timeout elapses without a value, throws a
java.util.concurrent.TimeoutException.</pre></div><div class="public" id="var-wait-stage"><h3>wait-stage</h3><div class="usage"><code>(wait-stage interval)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-watch-channel"><h3>watch-channel</h3><div class="usage"><code>(watch-channel reference)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-with-timeout"><h3>with-timeout</h3><div class="usage"><code>(with-timeout interval result)</code></div><pre class="doc">Returns a new result that will mimic the original result, unless 'interval' milliseconds elapse, in which
case it will realize as a 'lamina/timeout!' error.</pre></div><div class="public" id="var-zip"><h3>zip</h3><div class="usage"><code>(zip channels)</code><code>(zip most-frequent? channels)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-zip-all"><h3>zip-all</h3><div class="usage"><code>(zip-all channels)</code></div><pre class="doc">something goes here
</pre></div></div></body></html>