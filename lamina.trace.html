<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>lamina.trace documentation</title></head><body><div id="header"><h1><a href="index.html">Lamina 0.5.0-beta12 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="lamina.api.html"><span>lamina.api</span></a></li><li><a href="lamina.core.html"><span>lamina.core</span></a></li><li><a href="lamina.executor.html"><span>lamina.executor</span></a></li><li><a href="lamina.stats.html"><span>lamina.stats</span></a></li><li><a href="lamina.time.html"><span>lamina.time</span></a></li><li class="current"><a href="lamina.trace.html"><span>lamina.trace</span></a></li><li><a href="lamina.viz.html"><span>lamina.viz</span></a></li><li><a href="lamina.walk.html"><span>lamina.walk</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="lamina.trace.html#var-aggregating-trace-router"><span>aggregating-trace-router</span></a></li><li><a href="lamina.trace.html#var-analyze-timings"><span>analyze-timings</span></a></li><li><a href="lamina.trace.html#var-canonical-probe-name"><span>canonical-probe-name</span></a></li><li><a href="lamina.trace.html#var-defn-instrumented"><span>defn-instrumented</span></a></li><li><a href="lamina.trace.html#var-distill-timing"><span>distill-timing</span></a></li><li><a href="lamina.trace.html#var-error-probe-channel"><span>error-probe-channel</span></a></li><li><a href="lamina.trace.html#var-instrument"><span>instrument</span></a></li><li><a href="lamina.trace.html#var-instrumented-fn"><span>instrumented-fn</span></a></li><li><a href="lamina.trace.html#var-local-trace-router"><span>local-trace-router</span></a></li><li><a href="lamina.trace.html#var-merge-distilled-timings"><span>merge-distilled-timings</span></a></li><li><a href="lamina.trace.html#var-probe-channel"><span>probe-channel</span></a></li><li><a href="lamina.trace.html#var-probe-enabled%3F"><span>probe-enabled?</span></a></li><li><a href="lamina.trace.html#var-probe-names"><span>probe-names</span></a></li><li><a href="lamina.trace.html#var-query-seq"><span>query-seq</span></a></li><li><a href="lamina.trace.html#var-query-stream"><span>query-stream</span></a></li><li><a href="lamina.trace.html#var-register-context-builder"><span>register-context-builder</span></a></li><li><a href="lamina.trace.html#var-reset-probes"><span>reset-probes</span></a></li><li><a href="lamina.trace.html#var-select-probes"><span>select-probes</span></a></li><li><a href="lamina.trace.html#var-sympathetic-probe-channel"><span>sympathetic-probe-channel</span></a></li><li><a href="lamina.trace.html#var-time*"><span>time*</span></a></li><li><a href="lamina.trace.html#var-trace"><span>trace</span></a></li><li><a href="lamina.trace.html#var-trace*"><span>trace*</span></a></li><li><a href="lamina.trace.html#var-trace-router"><span>trace-router</span></a></li><li><a href="lamina.trace.html#var-tracing%3F"><span>tracing?</span></a></li><li><a href="lamina.trace.html#var-with-instrumentation"><span>with-instrumentation</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>lamina.trace documentation</h2><pre class="doc"></pre><div class="public" id="var-aggregating-trace-router"><h3>aggregating-trace-router</h3><div class="usage"><code>(aggregating-trace-router endpoint-router)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-analyze-timings"><h3>analyze-timings</h3><div class="usage"><code>(analyze-timings {:keys [period window task-queue expiration quantiles], :or {task-queue (time/task-queue), period (time/period)}, :as options} ch)</code></div><pre class="doc">Aggregates timings, and periodically emits statistical information about them.
</pre></div><div class="public" id="var-canonical-probe-name"><h3>canonical-probe-name</h3><div class="usage"><code>(canonical-probe-name x)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-defn-instrumented"><h3>defn-instrumented</h3><div class="usage"><code>(defn-instrumented fn-name &amp; body)</code></div><pre class="doc">A def form of (instrumented-fn...). Options can be defined in the function metadata:

(defn-instrumented foo
  {:implicit? false
   :timeout (constantly 1000)}
  &quot;Here's a doc-string&quot;
  [x]
  ...)

The :name can be explicitly defined, but will default to

  the:function:namespace:the-function-name

</pre></div><div class="public" id="var-distill-timing"><h3>distill-timing</h3><div class="usage"><code>(distill-timing timing)</code></div><pre class="doc">Returns a distillation of the timing object, containing only :task, :durations, :context, and :sub-tasks.
This is an idempotent operation.

This data structure can be merged using merge-distilled-timings.</pre></div><div class="public" id="var-error-probe-channel"><h3>error-probe-channel</h3><div class="usage"></div><pre class="doc">Like probe-channel, but if the probe is not active every message enqueued into the channe will be
logged as an error.</pre></div><div class="public" id="var-instrument"><h3>instrument</h3><div class="usage"><code>(instrument f {:keys [executor capture timeout probes implicit? with-bindings?], :as options, :or {implicit? true, capture :in-out, with-bindings? false}})</code></div><pre class="doc">A general purpose transform for functions, allowing for tracing their execution,
 defining timeouts, and deferring their execution onto a thread pool.

 Instrumenting a function does not change its behavior in any way (unless an
 :executor is defined, see below).  This can be a powerful tool for both
 understanding complex tasks during development, and monitoring their behavior in
 production.

 ---------
 OVERHEAD

 Instrumenting adds some overhead to a function, equivalent to the performance
 difference between calling

   (+ 1 2 3)

 and

   (apply + [1 2 3])

 If you'd happily call 'apply' on the function being instrumented, chances are you
  won't notice the difference.

 ---------
 PROBES

 Instrumenting a function creates 'enter', 'return', and 'error' probes.  A :name
 must be specified, and probe names will be of the structure name:enter,
 name:return, etc.  Data emitted by these probes may be captured by other functions
 if :implicit? is set to true, which is the default.

 When the function is invoked, the 'enter' probe emits a hash of the form

   :name        - the :name specified in the options
   :timestamp   - time of invocation in milliseconds since the epoch
   :args        - a list of arguments passed to the function

 When the function completes and the value is realized, the 'return' probe
 will emit the data above, and also:

   :duration    - the time elapsed since the invocation, in nanoseconds
   :result      - the value returned by the function
   :sub-tasks   - 'return' probe data, less :result, for all implicit instrumented
   sub-functions

 If an error is thrown, or the value is realized as an error, :result is replaced by

   :error       - the exception thrown or realized error

 A :probes option may be defined, giving a hash of probe names onto channels that
 will consume their data:

   {:error (channel-&gt;&gt; (sink #(println &quot;ERROR:&quot; %)))
    :return (channel-&gt;&gt; (sink #(println &quot;Given&quot; (:args %) &quot;, returned&quot; (:result %))))}

----------
TIMEOUTS

A :timeout option may be specified, which should be a function that takes the
arguments passed to the function, and returns the timeout in milliseconds or nil
for no timeout.  If the timeout elapses without any value, the returned result will
 be realized as an error of type 'lamina/timeout!'.

----------
EXECUTORS

If an :executor is specified, the function will be executed on that thread pool,
and return an unrealized result representing its eventual value.

In this case, :timeout will also interrupt the thread if it is still actively
computing the value, and the 'return' probe will include an :enqueued-duration
parameter that describes the time, in nanoseconds, spent waiting to be executed.</pre></div><div class="public" id="var-instrumented-fn"><h3>instrumented-fn</h3><div class="usage"><code>(instrumented-fn fn-name {:keys [executor capture with-bindings? implicit? timeout probes], :or {capture :in-out, with-bindings? false, implicit? true}, :as options} &amp; fn-tail)</code></div><pre class="doc">A compile-time version of (instrument ...).

(instrumented-fn
  foo
  {:implicit? false}
  [x y]
  (+ x y))

The </pre></div><div class="public" id="var-local-trace-router"><h3>local-trace-router</h3><div class="usage"></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-merge-distilled-timings"><h3>merge-distilled-timings</h3><div class="usage"><code>(merge-distilled-timings &amp; distilled-timings)</code></div><pre class="doc">Returns a list of one or distilled timings, where :durations have been concatenated together for
identical tasks.</pre></div><div class="public" id="var-probe-channel"><h3>probe-channel</h3><div class="usage"></div><pre class="doc">Returns a probe channel for the given name.  Keywords will be converted to simple strings, and
sequences will be joined with ':' characters.

[:a &quot;b&quot; [1 2 3]] =&gt; &quot;a:b:1:2:3&quot;</pre></div><div class="public" id="var-probe-enabled%3F"><h3>probe-enabled?</h3><div class="usage"><code>(probe-enabled? _)</code></div><pre class="doc">Returns true if the probe has downstream channels.
</pre></div><div class="public" id="var-probe-names"><h3>probe-names</h3><div class="usage"><code>(probe-names)</code></div><pre class="doc">Returns a list of all existing probes.
</pre></div><div class="public" id="var-query-seq"><h3>query-seq</h3><div class="usage"><code>(query-seq transform-descriptor s {:keys [timestamp payload period seq-generator], :or {payload identity}, :as options})</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-query-stream"><h3>query-stream</h3><div class="usage"><code>(query-stream transform-descriptor ch {:keys [task-queue timestamp payload period stream-generator], :or {payload identity}, :as options})</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-register-context-builder"><h3>register-context-builder</h3><div class="usage"><code>(register-context-builder f)</code></div><pre class="doc">Defines a function which is given a default context map, and returns a modified
context map.</pre></div><div class="public" id="var-reset-probes"><h3>reset-probes</h3><div class="usage"><code>(reset-probes)</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-select-probes"><h3>select-probes</h3><div class="usage"><code>(select-probes &amp; wildcard-strings-or-regexes)</code></div><pre class="doc">Activates all probes that match the given strings or regexes, and returns a channel that will emit
all messages from these probes.</pre></div><div class="public" id="var-sympathetic-probe-channel"><h3>sympathetic-probe-channel</h3><div class="usage"><code>(sympathetic-probe-channel ch)</code></div><pre class="doc">A channel that only lets messages through if 'ch' has downstream channels.
</pre></div><div class="public" id="var-time*"><h3>time*</h3><div class="usage"><code>(time* &amp; body)</code></div><pre class="doc">A somewhat more useful variant of (time ...), which captures the sub-timings of all instrumented functions
called within the scope.  If the body returns an unrealized value, time* will wait for it to become realized.</pre></div><div class="public" id="var-trace"><h3>trace</h3><div class="usage"><code>(trace probe &amp; body)</code></div><pre class="doc">Enqueues a value into the probe-channel described by 'probe'.  The body is executed only
if there is a consumer for the probe channel; this is essentially a log statement that is
only active if someone is paying attention.

For performance reasons, the probe name must be something that can be resolved at compile-time.</pre></div><div class="public" id="var-trace*"><h3>trace*</h3><div class="usage"><code>(trace* probe &amp; body)</code></div><pre class="doc">A variant of trace that allows the probe name to be resolved at runtime.
</pre></div><div class="public" id="var-trace-router"><h3>trace-router</h3><div class="usage"><code>(trace-router {:keys [generator topic-&gt;id on-subscribe on-unsubscribe timestamp payload task-queue], :or {payload identity, task-queue (time/task-queue)}, :as options})</code></div><pre class="doc">something goes here
</pre></div><div class="public" id="var-tracing%3F"><h3>tracing?</h3><div class="usage"><code>(tracing?)</code></div><pre class="doc">Returns true when called inside an active function trace scope, false otherwise.
</pre></div><div class="public" id="var-with-instrumentation"><h3>with-instrumentation</h3><div class="usage"><code>(with-instrumentation &amp; body)</code></div><pre class="doc">Returns the full timing data for all code called within the scope.
</pre></div></div></body></html>